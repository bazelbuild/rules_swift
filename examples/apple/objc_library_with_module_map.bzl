"""objc_library_with_module_map wraps an objc_library, extracting the module map generated by rules_swift's
swift_clang_module_aspect, and adds it to the CcInfo provider so that it can be used in upstream ObjC compilation."""

load("@rules_cc//cc/common:cc_common.bzl", "cc_common")
load("@rules_cc//cc/common:cc_info.bzl", "CcInfo")
load("@rules_cc//cc/common:objc_info.bzl", "ObjcInfo")
load("//swift:providers.bzl", "SwiftInfo")
load("//swift:swift_clang_module_aspect.bzl", "swift_clang_module_aspect")

def _objc_library_with_module_map_impl(ctx):
    library = ctx.attr.library

    return [
        DefaultInfo(
            files = depset(
                [],
                transitive = [
                    library[DefaultInfo].files,
                ],
            ),
            runfiles = ctx.runfiles(
                collect_data = True,
                collect_default = True,
            ),
        ),
        _get_cc_info_with_module_map(library),
        coverage_common.instrumented_files_info(
            ctx,
            dependency_attributes = ["library"],
        ),
        ObjcInfo(
            providers = [library[ObjcInfo]] if ObjcInfo in library else [],
        ),
        SwiftInfo(
            swift_infos = [library[SwiftInfo]] if SwiftInfo in library else [],
        ),
    ]

def _get_cc_info_with_module_map(library):
    if SwiftInfo not in library or not library[SwiftInfo].direct_modules:
        return library[CcInfo]

    direct_modules = library[SwiftInfo].direct_modules
    if len(direct_modules) > 1:
        fail("Expected exactly one direct module, but got %s" % len(direct_modules))

    direct_module = direct_modules[0]
    if not hasattr(direct_module, "clang"):
        fail("Expected direct module to have clang info, but got %s" % direct_module)

    module_map = direct_module.clang.module_map
    if not module_map:
        fail("Expected direct module to have a module map, but got %s" % direct_module)

    compilation_context = cc_common.create_compilation_context(
        # Including the module map as a header ensures that is an input for compilation actions. Ideally objc_library
        # would have a catch-all attribute for action inputs like swift_library's "swiftc_inputs", but it does not.
        headers = depset([module_map]),
        # This adds the modulemap directory to clang + swiftc's include paths.
        includes = depset([module_map.dirname]),
    )

    return cc_common.merge_cc_infos(
        direct_cc_infos = [
            CcInfo(compilation_context = compilation_context),
        ],
        cc_infos = [library[CcInfo]],
    )

objc_library_with_module_map = rule(
    implementation = _objc_library_with_module_map_impl,
    attrs = {
        "library": attr.label(
            doc = """An objc_library target that will be wrapped by this rule.""",
            mandatory = True,
            # If the library is a source-less objc_library, the aspect won't create a SwiftInfo.
            providers = [[CcInfo], [CcInfo, SwiftInfo]],
            aspects = [swift_clang_module_aspect],
        ),
    },
    doc = """objc_library_with_module_map wraps an objc_library, extracting the module map generated by rules_swift's
swift_clang_module_aspect, and adds it to the CcInfo provider so that it can be used in upstream ObjC compilation.""",
)
