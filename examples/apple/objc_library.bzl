"""objc_library_with_module_map wraps an objc_library, extracting the module map generated by rules_swift's
swift_clang_module_aspect, and adds it to the CcInfo provider so that it can be used in upstream ObjC compilation."""

load("@cc_compatibility_proxy//:proxy.bzl", _upstream_objc_library = "objc_library")
load("@rules_cc//cc/common:cc_common.bzl", "cc_common")
load("@rules_cc//cc/common:cc_info.bzl", "CcInfo")
load("@rules_cc//cc/common:objc_info.bzl", "ObjcInfo")
load("//swift:module_name.bzl", "derive_swift_module_name")
load("//swift:providers.bzl", "SwiftInfo")
load("//swift:swift_clang_module_aspect.bzl", "swift_clang_module_aspect")
load("//swift:swift_interop_info.bzl", "create_swift_interop_info")
load("//swift/internal:feature_names.bzl", "SWIFT_FEATURE_MODULE_MAP_HOME_IS_CWD", "SWIFT_FEATURE_MODULE_MAP_NO_PRIVATE_HEADERS")
load("//swift/internal:features.bzl", "configure_features", "is_feature_enabled")
load("//swift/internal:module_maps.bzl", "write_module_map")
load("//swift/internal:toolchain_utils.bzl", "get_swift_toolchain", "use_swift_toolchain")

def _objc_library_impl(ctx):
    requested_features = ctx.features
    swift_toolchain = get_swift_toolchain(ctx)
    unsupported_features = ctx.disabled_features
    feature_configuration = configure_features(
        ctx = ctx,
        requested_features = requested_features,
        swift_toolchain = swift_toolchain,
        unsupported_features = unsupported_features,
    )

    providers = ctx.super()
    cc_info, swift_info, swift_interop_info, passthrough_providers = _get_providers(providers)

    module_map, new_swift_interop_info = _derive_module(
        ctx,
        cc_info = cc_info,
        feature_configuration = feature_configuration,
        requested_features = requested_features,
        swift_info = swift_info,
        swift_interop_info = swift_interop_info,
        unsupported_features = unsupported_features,
    )
    if not module_map:
        fail("expected module map")

    new_cc_info = cc_common.merge_cc_infos(
        direct_cc_infos = [
            CcInfo(
                compilation_context = cc_common.create_compilation_context(
                    headers = depset([module_map]),
                    includes = depset([module_map.dirname]),
                ),
            ),
        ],
        cc_infos = [cc_info],
    )

    return passthrough_providers + [new_cc_info] + ([new_swift_interop_info] if new_swift_interop_info else [])

def _get_providers(providers):
    cc_info = None
    swift_info = None
    swift_interop_info = None
    passthrough_providers = []

    for provider in providers:
        if type(provider) == "CcInfo":
            cc_info = provider
        elif type(provider) == "SwiftInfo":
            swift_info = provider
            passthrough_providers.append(provider)
        elif type(provider) == "SwiftInteropInfo":
            swift_interop_info = provider
        else:
            passthrough_providers.append(provider)

    return cc_info, swift_info, swift_interop_info, passthrough_providers

def _derive_module(
        ctx,
        *,
        cc_info,
        feature_configuration,
        requested_features,
        swift_info,
        swift_interop_info,
        unsupported_features):
    if swift_info and swift_info.direct_modules:
        direct_modules = swift_info.direct_modules
    else:
        direct_modules = []

    if ctx.attr.module_map:
        module_map = ctx.attr.module_map
        new_swift_interop_info = swift_interop_info
    elif swift_interop_info and swift_interop_info.module_map:
        module_map = swift_interop_info.module_map
        new_swift_interop_info = swift_interop_info
    elif direct_modules and len(direct_modules) == 1 and hasattr(direct_modules[0], "clang"):
        module_map = direct_modules[0].clang.module_map
        new_swift_interop_info = swift_interop_info
    else:
        if ctx.attr.module_name:
            module_name = ctx.attr.module_name
        elif swift_interop_info and swift_interop_info.module_name:
            module_name = swift_interop_info.module_name
        else:
            module_name = derive_swift_module_name(ctx.label)

        dependent_module_names = [
            module.name
            for module in direct_modules
            if module.clang
        ]

        module_map, new_swift_interop_info = _write_module_map(
            actions = ctx.actions,
            cc_info = cc_info,
            dependent_module_names = dependent_module_names,
            feature_configuration = feature_configuration,
            label = ctx.label,
            module_name = module_name,
            swift_info = swift_info,
            requested_features = requested_features,
            swift_interop_info = swift_interop_info,
            unsupported_features = unsupported_features,
        )

    return module_map, new_swift_interop_info

def _write_module_map(
        *,
        actions,
        cc_info,
        dependent_module_names,
        feature_configuration,
        label,
        module_name,
        swift_info,
        requested_features,
        swift_interop_info,
        unsupported_features):
    workspace_relative = is_feature_enabled(
        feature_configuration = feature_configuration,
        feature_name = SWIFT_FEATURE_MODULE_MAP_HOME_IS_CWD,
    )
    exclude_private_headers = is_feature_enabled(
        feature_configuration = feature_configuration,
        feature_name = SWIFT_FEATURE_MODULE_MAP_NO_PRIVATE_HEADERS,
    )

    if exclude_private_headers:
        private_headers = []
    else:
        private_headers = cc_info.compilation_context.direct_private_headers

    def _path_sorting_key(file):
        return file.path

    public_headers = sorted(
        cc_info.compilation_context.direct_public_headers,
        key = _path_sorting_key,
    )
    textual_headers = sorted(
        cc_info.compilation_context.direct_textual_headers,
        key = _path_sorting_key,
    )

    if swift_interop_info:
        exclude_headers = swift_interop_info.exclude_headers
    else:
        exclude_headers = []

    exclude_headers = sorted(exclude_headers, key = _path_sorting_key)

    module_map = actions.declare_file(
        "{}_modulemap/_/module.modulemap".format(label.name),
    )

    write_module_map(
        actions = actions,
        module_map_file = module_map,
        module_name = module_name,
        dependent_module_names = dependent_module_names,
        exclude_headers = exclude_headers,
        exported_module_ids = ["*"],
        public_headers = public_headers,
        public_textual_headers = textual_headers,
        private_headers = sorted(private_headers, key = _path_sorting_key),
        workspace_relative = workspace_relative,
    )

    return module_map, create_swift_interop_info(
        exclude_headers = exclude_headers,
        module_map = module_map,
        module_name = module_name,
        requested_features = requested_features,
        swift_infos = [swift_info] if swift_info else [],
        unsupported_features = unsupported_features,
    )

objc_library_rule = rule(
    implementation = _objc_library_impl,
    parent = _upstream_objc_library,
    toolchains = use_swift_toolchain(),
)

def objc_library(
        *,
        name,
        enable_modules = True,
        **kwargs):
    objc_library_rule(
        name = name,
        enable_modules = enable_modules,
        **kwargs
    )
