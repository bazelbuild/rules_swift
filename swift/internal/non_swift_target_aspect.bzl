# Copyright 2018 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Attaches `SwiftInfo` providers as needed to non-Swift targets.

There are two reasons to attach a `SwiftInfo` provider to non-Swift targets:

*   For a `cc_library`, we want to generate a module map so that it can be
    imported directly by Swift, as well as propagate the merged `SwiftInfo`s of
    its children so that information from those dependencies isn't lost. (For
    example, consider a `swift_library` that depends on an `objc_library` that
    depends on a `swift_library`.)

    The modules generated by this aspect have names that are automatically
    derived from the label of the `cc_library` target, using the same logic used
    to derive the module names for Swift targets.

*   For any other target, we want to propagate the merged `SwiftInfo`s of its
    children so that types defined in those modules are available to the parent
    modules. For example, if a Swift target indirectly depends on another Swift
    target through an Objective-C target, the Objective-C target's
    implementation doesn't know that it needs to propagate the Swift info, so
    the aspect handles that.

    The exception to this is C++ dependencies, where we explicitly discard
    indirect dependencies because we don't have a good way to handle some of the
    targets that show up in those graphs yet.

This aspect is an implementation detail of the Swift build rules and is not
meant to be attached to other rules or run independently.
"""

load(":attrs.bzl", "swift_toolchain_attrs")
load(":compiling.bzl", "derive_module_name")
load(":derived_files.bzl", "derived_files")
load(":feature_names.bzl", "SWIFT_FEATURE_MODULE_MAP_HOME_IS_CWD")
load(":features.bzl", "configure_features", "is_feature_enabled")
load(":module_maps.bzl", "write_module_map")
load(":providers.bzl", "SwiftInfo", "SwiftToolchainInfo", "create_swift_info")
load(":utils.bzl", "get_providers")

def _tagged_target_module_name(label, tags):
    """Returns the module name of a `swift_module`-tagged target.

    The `swift_module` tag may take one of two forms:

    *   `swift_module`: By itself, this indicates that the target is compatible
        with Swift and should be given a module name that is derived from its
        target label.
    *   `swift_module=name`: The module should be given the name `name`.

    If the `swift_module` tag is not present, no module name is used or
    computed.

    Since tags are unprocessed strings, nothing prevents the `swift_module` tag
    from being listed multiple times on the same target with different values.
    For this reason, the aspect uses the _last_ occurrence that it finds in the
    list.

    Args:
        label: The target label from which a module name should be derived, if
            necessary.
        tags: The list of tags from the `cc_library` target to which the aspect
            is being applied.

    Returns:
        If the `swift_module` tag was present, then the return value is the
        explicit name if it was of the form `swift_module=name`, or the
        label-derived name if the tag was not followed by a name. Otherwise, if
        the tag is not present, `None` is returned.
    """
    module_name = None
    for tag in tags:
        if tag == "swift_module":
            module_name = derive_module_name(label)
        elif tag.startswith("swift_module="):
            _, _, module_name = tag.partition("=")
    return module_name

def _handle_cc_target(
        aspect_ctx,
        feature_configuration,
        swift_infos,
        swift_toolchain,
        target):
    """Processes a C++ target that is a dependency of a Swift target.

    Args:
        aspect_ctx: The aspect's context.
        feature_configuration: The current feature configuration.
        swift_infos: The `SwiftInfo` providers of the current target's
            dependencies, which should be merged into the `SwiftInfo` provider
            created and returned for this C++ target.
        swift_toolchain: The Swift toolchain being used to build this target.
        target: The C++ target to which the aspect is currently being applied.

    Returns:
        A list of providers that should be returned by the aspect.
    """
    attr = aspect_ctx.rule.attr

    module_name = _tagged_target_module_name(
        label = target.label,
        tags = attr.tags,
    )

    if not module_name:
        if swift_infos:
            return [create_swift_info(swift_infos = swift_infos)]
        else:
            return []

    # Determine if the toolchain requires module maps to use
    # workspace-relative paths or not.
    workspace_relative = is_feature_enabled(
        feature_configuration = feature_configuration,
        feature_name = SWIFT_FEATURE_MODULE_MAP_HOME_IS_CWD,
    )

    module_map_file = derived_files.module_map(
        actions = aspect_ctx.actions,
        target_name = target.label.name,
    )
    write_module_map(
        actions = aspect_ctx.actions,
        headers = [
            file
            for target in attr.hdrs
            for file in target.files.to_list()
        ],
        module_map_file = module_map_file,
        module_name = module_name,
        textual_headers = [
            file
            for target in attr.textual_hdrs
            for file in target.files.to_list()
        ],
        workspace_relative = workspace_relative,
    )

    return [create_swift_info(
        modulemaps = [module_map_file],
        module_name = module_name,
        swift_infos = swift_infos,
    )]

def _non_swift_target_aspect_impl(target, aspect_ctx):
    # Do nothing if the target already propagates `SwiftInfo`.
    if SwiftInfo in target:
        return []

    attr = aspect_ctx.rule.attr
    deps = getattr(attr, "deps", [])
    swift_infos = get_providers(deps, SwiftInfo)

    swift_toolchain = aspect_ctx.attr._toolchain_for_aspect[SwiftToolchainInfo]
    feature_configuration = configure_features(
        ctx = aspect_ctx,
        requested_features = aspect_ctx.features,
        swift_toolchain = swift_toolchain,
        unsupported_features = aspect_ctx.disabled_features,
    )

    # TODO(b/143292468): Stop checking the rule kind and look for the presence
    # of `CcInfo` once `CcInfo.compilation_context` propagates direct headers
    # and direct textual headers separately.
    if aspect_ctx.rule.kind == "cc_library":
        return _handle_cc_target(
            aspect_ctx = aspect_ctx,
            feature_configuration = feature_configuration,
            swift_infos = swift_infos,
            swift_toolchain = swift_toolchain,
            target = target,
        )

    # If it's any other rule, just merge the `SwiftInfo` providers from its
    # deps.
    if swift_infos:
        return [create_swift_info(swift_infos = swift_infos)]

    return []

non_swift_target_aspect = aspect(
    attrs = swift_toolchain_attrs(
        toolchain_attr_name = "_toolchain_for_aspect",
    ),
    attr_aspects = ["deps"],
    fragments = ["cpp"],
    implementation = _non_swift_target_aspect_impl,
)
